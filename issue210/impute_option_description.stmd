# Impute option

<ul>
<li>[Description](#description)</li>
<li>[Examples](#examples)
<ul>
<li>[nuchange](#nuchange) </li>
<li>[stag](#stag)</li>
<li>[instag](#instag)</li>
</ul>
</li>
<li>[How the imputation works on the event-time dummies](#how-the-imputation-works-on-the-event\-time-dummies)</li>
</ul>

## Description
<div style="text-align: justify">  
**impute(type, [saveimp])** imputes leads, lags, and missing values of *policyvar* and uses this new variable as the actual *policyvar*.  **type** determines the imputation rule. The suboption **saveimp** adds the new variable to the database as *policyvar_imputed*. The following imputation types are available:

* **impute([nuchange](#nuchange))** imputes missing values in *policyvar* according to *no unobserved change*: it assumes that for each unit: i) in periods before the first observed value, the policy value is the same as the first observed value and; ii) in periods after the last observed value, the policy value is the same as the last observed value.

* **impute([stag](#stag))** applies *no unobserved change* if *policyvar* satisfies staggered-adoption assumptions for all units: i) *policyvar* must be binary and; ii) once *policyvar* reaches the adopted-policy state, it never reverts to the unadopted-policy state. See [Freyaldenhoven et al. (2021)](https://www.nber.org/papers/w29170) for detailed explanation of the staggered adoption case. 

* **impute([instag](#instag))** applies **impute(stag)** and additionally imputes missing values inside the observed data range: a missing value or a group of them will be imputed only if they are both preceded and followed by the unadopted-policy state or by the adopted-policy state.
</div>

## Examples

We want to estimate the dynamic effects of being a union member on wage. We will use the National Longitudinal Survey data from Stata's example datasets.

	webuse nlswork, clear
	
This dataset has many missing observations. For the sake of the example, we will create a time variable that ignores these gaps.

	by idcode (year): gen time=_n
	xtset idcode time

The *policyvar* *union* reverts to the unadopted-policy-state for several units. We generate a *policyvar* that follows staggered adoption.

	by idcode (time): gen union2=sum(union)
	replace union2=1 if union2>1 
	order time union union2, after(year)

Now we add some missing values to the *policyvar* for this example and display how the *policyvar* looks for unit 2.

	replace union2=. if idcode==2 & inlist(time, 1,8,9,11,12)
	list idcode time union2 if idcode==2, noobs

#### nuchange 

First, we estimate an event study where we impute outer missing values in the *policyvar* without verifying staggered adoption, i.e., according to **[nuchange](#description)**. We also want to add the new *policyvar* to the database. We can do this using the **saveimp** suboption.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) impute(nuchange, saveimp)

Compare the original *policyvar* and the imputed *policyvar* for unit 2.
	list idcode time union2 union2_imputed if idcode==2, noobs

Drop the imputed *policyvar*.

	drop union2_imputed

#### stag 

Now, we estimate an event-study imputing outer missing values in the *policyvar* verifying staggered-adoption, i.e., according to **[stag](#description)**, and save the imputed *policyvar*. 

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
				policyvar(union2) window(3) impute(stag, saveimp)
					  
Compare the original *policyvar* and the imputed *policyvar* for unit 2.

	list idcode time union2 union2_imputed if idcode==2, noobs

Drop the imputed *policyvar*.

	drop union2_imputed
					  
#### instag  

Last, we estimate an event-study imputing outer and inner missing values in the *policyvar* verifying staggered adoption, i.e., according to **[instag](#description)**, and save the imputed *policyvar*.  

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) impute(instag, saveimp)
			
Compare the original *policyvar* and the imputed *policyvar* for unit 2.

	list idcode time union2 union2_imputed if idcode==2, noobs

## How the imputation works on the event-time dummies 

Now we display how the imputation works on the event-time dummies. First, we differentiate the *policyvar*. 

	gen union2_d=d.union2
	
Estimate an event-study without imputing the *policyvar* and save the event-time dummies by the *savek* option.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) savek(vv)
			
Now, we display the event-time dummies for a unit. We can verify that this set of event-time dummies corresponds to different leads of the differentiated *policyvar* (see equation 2 in [Freyaldenhoven et al. (2021)](https://www.nber.org/papers/w29170)).

	list idcode time union2 union2_d vv_eq_m4 vv_eq_m3 vv_eq_m2 vv_eq_m1 if idcode==24, noobs

Drop the event-time dummies. 
	drop vv*
	
Estimate the same model, but with imputation according to **[stag](#description)**.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
	policyvar(union2) window(3) savek(vv) impute(stag)
			
Now, we display the event-time dummies for the same unit. We can verify that **xtevent** imputed event-time dummies despite the *policyvar* not having missing values in its observed data range. This imputation happens because the imputation works on both the observed and the unobserved data range of the *policyvar*.

	list idcode time union2 union2_d vv_eq_m4 vv_eq_m3 vv_eq_m2 vv_eq_m1 if idcode==24, noobs
	
