# Impute option            
                
**impute(type, [saveimp])** imputes missing values in *policyvar* and uses the imputed variable as the independent policy variable in estimation. **type** determines the imputation rule. The suboption **saveimp** adds the new variable to the database as *policyvar_imputed*. The following imputation types are available:

* **impute(nuchange)** imputes missing values in *policyvar* under an assumption of *no unobserved changes*. It assumes that for each unit: i) The policy variable's value is the same as the first observed value in periods before the first observed value, and ii) The policy variable's value is the same as the last observed value in periods after the last observed value

* **impute(stag)** imputes missing values in the *policyvar* under an assumption of no unobserved changes and staggered adoption. *policyvar* must satisfy staggered-adoption assumptions for all units: i) *policyvar* must be binaryl; ii) once *policyvar* reaches the adopted-policy state, it never reverts to the unadopted-policy state; iii) the first-observed value must be the unadopted-policy-state value, and the last-observed value must be the adopted-policy-state value, and iv) all *policyvar* values in the observed data range must be either adopted-policy-state values or unadopted-policy-state values.

* **impute(instag)** imputes missing values in the *policyvar* under staggered adoption assumptions and additionally imputes missing values inside the observed data range: *xtevent* imputes a missing value or a group of them only if they are both preceded and followed by values corresponding to the unadopted-policy state or the adopted-policy state.

## Examples

We want to estimate the dynamic effects of being a union member on the wage. We will use the National Longitudinal Survey data from Stata's example datasets.

	webuse nlswork, clear
	
This dataset has many missing observations. For the sake of the example, we will create a time variable that ignores these gaps.

	by idcode (year): gen time=_n
	xtset idcode time

The *policyvar* *union* reverts to the unadopted-policy-state for several units. We generate a *policyvar* that follows staggered adoption.

	by idcode (time): gen union2=sum(union)
	replace union2=1 if union2>1 
	order time union union2, after(year)

Now we add some missing values to the *policyvar* for this example and display how the *policyvar* looks for unit 2.

	replace union2=. if idcode==2 & inlist(time, 1,8,9,11,12)
	list idcode time union2 if idcode==2, noobs

#### nuchange 

First, we estimate an event-study where we impute outer missing values in the *policyvar* without verifying staggered adoption, i.e., according to **nuchange**. We also want to add the new *policyvar* to the database. We can do this using the **saveimp** suboption.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) impute(nuchange, saveimp)

Compare the original *policyvar* and the imputed *policyvar* for unit 2.
	list idcode time union2 union2_imputed if idcode==2, noobs

Drop the imputed *policyvar*.

	drop union2_imputed

#### stag 

Now, we estimate an event-study imputing outer missing values in the *policyvar* verifying staggered adoption, i.e., according to **stag**, and save the imputed *policyvar*. 

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
				policyvar(union2) window(3) impute(stag, saveimp)
					  
Compare the original *policyvar* and the imputed *policyvar* for unit 2.

	list idcode time union2 union2_imputed if idcode==2, noobs

Drop the imputed *policyvar*.

	drop union2_imputed
					  
#### instag  

Last, we estimate an event-study imputing outer and inner missing values in the *policyvar* verifying staggered adoption, i.e., according to **instag**, and save the imputed *policyvar*.  

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) impute(instag, saveimp)
			
Compare the original *policyvar* and the imputed *policyvar* for unit 2.

	list idcode time union2 union2_imputed if idcode==2, noobs

## How the imputation works on the event-time dummies 

Now we display how the imputation works on the event-time dummies. First, we differentiate the *policyvar*. 

	gen union2_d=d.union2
	
Estimate an event study without imputing the *policyvar* and save the event-time dummies by the *savek* option.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
		policyvar(union2) window(3) savek(vv)
			
Now, we display the event-time dummies for a unit. We can verify that this set of event-time dummies corresponds to different leads of the differentiated *policyvar* (see equation 2 in [Freyaldenhoven et al. (2021)](https://www.nber.org/papers/w29170)).

	list idcode time union2 union2_d vv_eq_m4 vv_eq_m3 vv_eq_m2 vv_eq_m1 if idcode==24, noobs

Drop the event-time dummies. 
	drop vv*
	
Estimate the same model, but with imputation according to **stag**.

	xtevent ln_w age c.age#c.age ttl_exp c.ttl_exp#c.ttl_exp tenure , ///
	policyvar(union2) window(3) savek(vv) impute(stag)
			
Now, we display the event-time dummies for the same unit. We can verify that *xtevent* imputed event-time dummies despite the *policyvar* not having missing values in its observed data range. This imputation happens because the imputation works on both the observed and the unobserved data range of the *policyvar*.

	list idcode time union2 union2_d vv_eq_m4 vv_eq_m3 vv_eq_m2 vv_eq_m1 if idcode==24, noobs
	
